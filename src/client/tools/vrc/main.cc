// Copyright (C) 2025 Yisi Yu
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// VRC全称为Vita Resource Compiler，用于解析资源文件

#include <fstream>
#include <iostream>
#include <set>
#include <sstream>
#include <string>
#include <vector>

#include "../third_party/nlohmann_json/json.hpp"
#include "base/files/file_path.h"
#include "base/files/file_util.h"
#include "base/strings/string_split.h"
#include "base/strings/sys_string_conversions.h"
#include "build/build_config.h"
#include "third_party/zlib-1.3/contrib/minizip/zip.h"

#define U8(x) (reinterpret_cast<const char*>(u8##x))
#define OUTPUT_SUFFIX FILE_PATH_LITERAL(".res")

namespace string_templates {

constexpr char kFileCommentHeaderCxx[] = R"(// Copyright (C) 2025 Yisi Yu
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// This file is generated by Vita Interface Compiler.
// Do not modify it.
)";

constexpr char kFileCommentStartCxx[] = R"(
#pragma once
)";

constexpr char kFileCommentEndCxx[] = R"(
)";

constexpr char kFileCommentHeaderLua[] = R"(-- Copyright (C) 2025 Yisi Yu

-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- This file is generated by Vita Interface Compiler.
-- Do not modify it.
)";

}  // namespace string_templates

const std::string kSupportLanguage[] = {"zh", "en", "ja"};
constexpr char kManifestName[] = "manifest.json";

std::string ToSysPath(const kiwi::base::FilePath& path) {
  std::string path_in_sys_encoding;
#if BUILDFLAG(IS_WIN)
  path_in_sys_encoding =
      kiwi::base::SysWideToMultiByte(path.value(), 0 /* CP_ACP */);
#else
  path_in_sys_encoding = path.AsUTF8Unsafe();
#endif
  return path_in_sys_encoding;
}

kiwi::base::FilePath FromSysPath(const char* path) {
#if BUILDFLAG(IS_WIN)
  kiwi::base::FilePath f(kiwi::base::SysMultiByteToWide(path, 0));
#else
  kiwi::base::FilePath f = kiwi::base::FilePath::FromUTF8Unsafe(path);
#endif
  return f;
}

std::string ReadFile(const std::string& filename) {
  std::ifstream file(filename, std::ios::in | std::ios::binary);
  std::ostringstream oss;
  if (file.is_open()) {
    oss << file.rdbuf();
    file.close();
  }
  return oss.str();
}

bool WriteFile(const std::string& content, const std::string& filename) {
  std::fstream file(filename, std::ios::out | std::ios::binary);

  // 检查文件是否成功打开
  if (file.is_open()) {
    file << content << std::endl;
    return true;
  }
  return false;
}

bool WriteToZip(zipFile zf,
                const char* filename,
                const char* data,
                size_t size) {
  zip_fileinfo info{0};
  int err = zipOpenNewFileInZip(zf, filename, &info, nullptr, 0, nullptr, 0,
                                nullptr, Z_DEFLATED, Z_DEFAULT_COMPRESSION);
  if (err != ZIP_OK)
    return false;

  err = zipWriteInFileInZip(zf, data, size);
  if (err != ZIP_OK)
    return false;

  zipCloseFileInZip(zf);
  return true;
}

struct ResourceItem {
  std::string id;
  std::map<std::string, std::string> resources;
};

std::vector<ResourceItem> LoadResourceFromJSON(
    const std::string& json_contents) {
  std::vector<ResourceItem> resource_map;

  nlohmann::json j = nlohmann::json::parse(json_contents.c_str());
  resource_map.clear();
  if (!j.is_array())
    return std::vector<ResourceItem>();

  for (const auto& i : j) {
    if (i.is_object()) {
      ResourceItem item;
      item.id = i["id"].get<std::string>();
      for (const auto& lang : kSupportLanguage) {
        if (!i.contains(lang))
          continue;

        std::string maybe_res = i[lang].get<std::string>();
        if (!maybe_res.empty())
          item.resources[lang] = maybe_res;
      }
      resource_map.push_back(item);
    }
  }
  return resource_map;
}

std::string GenerateCxx(const std::vector<ResourceItem>& resources,
                        std::string module_name) {
  std::vector<std::string> parts = kiwi::base::SplitString(
      module_name, ".", kiwi::base::WhitespaceHandling::TRIM_WHITESPACE,
      kiwi::base::SplitResult::SPLIT_WANT_NONEMPTY);
  module_name = parts[0];

  std::string enum_class_name = "Strings";
  if (parts.size() > 1 && parts[1] == "resources") {
    enum_class_name = "Resources";
  }

  std::string result;
  result += string_templates::kFileCommentHeaderCxx;
  result += string_templates::kFileCommentStartCxx;

  result += U8("// This file is a generated by vrc.\n"
               "// Don't modify it.\n"
               "\n"
               "#include \"vita/components/i18n/i18n.h\"\n\n"
               "namespace vita::") +
            module_name +
            U8(" {\n"
               "\n");

  result += U8("enum class ") + enum_class_name + U8(" {\n");
  for (size_t i = 0; i < resources.size(); ++i) {
    result += U8("  ") + resources[i].id + " = " + std::to_string(i) + ",\n";
  }
  result += U8("};\n"
               "\n"
               "} // namespace vita::") +
            module_name;

  result += string_templates::kFileCommentEndCxx;
  return result;
}

std::string GenerateLua(const std::vector<ResourceItem>& resources,
                        std::string module_name) {
  module_name = kiwi::base::SplitString(
      module_name, ".", kiwi::base::WhitespaceHandling::TRIM_WHITESPACE,
      kiwi::base::SplitResult::SPLIT_WANT_NONEMPTY)[0];

  std::string result;
  result += string_templates::kFileCommentHeaderLua;

  result += U8("-- This file is a generated by vrc.\n"
               "-- Don't modify it.\n"
               "\n"
               "local ") +
            module_name + U8(" = {}\n\n");

  result += module_name + U8(" = {\n");
  for (size_t i = 0; i < resources.size(); ++i) {
    result += U8("  ") + resources[i].id + " = " + std::to_string(i) + ",\n";
  }
  result += U8("};\n\n");
  result += U8("return ") + module_name + U8("\n");
  return result;
}

bool PackAllFileInResource(const kiwi::base::FilePath& rel_path,
                           const std::vector<ResourceItem>& resources,
                           const std::string& manifest,
                           const kiwi::base::FilePath& output_package) {
  zipFile zf = zipOpen(ToSysPath(output_package).c_str(), APPEND_STATUS_CREATE);
  if (!zf) {
    printf("Cannot create file %s\n", ToSysPath(output_package).c_str());
    return false;
  }

  if (!WriteToZip(zf, kManifestName, manifest.c_str(), manifest.size() + 1)) {
    printf("Write manifest error when generating %s\n",
           ToSysPath(output_package).c_str());
    zipClose(zf, nullptr);
    return false;
  }

  std::set<std::string> names;
  for (const auto& resource : resources) {
    for (const auto& [lang, name] : resource.resources) {
      if (!names.insert(name).second) {
        printf("Duplicated filename `%s` when generating %s\n", name.c_str(),
               ToSysPath(output_package).c_str());
        zipClose(zf, nullptr);
        return false;
      }

      kiwi::base::FilePath res_path =
          rel_path.Append(kiwi::base::FilePath::FromUTF8Unsafe(name));
      std::optional<std::vector<std::byte>> data =
          kiwi::base::ReadFileToBytes(res_path);
      if (data) {
        if (!WriteToZip(zf, name.c_str(),
                        reinterpret_cast<const char*>(data->data()),
                        data->size())) {
          printf("Write file `%s` error when generating %s\n", name.c_str(),
                 ToSysPath(output_package).c_str());
          zipClose(zf, nullptr);
          return false;
        }
      } else {
        printf("Read file data `%s` error when generating %s\n",
               ToSysPath(res_path).c_str(), ToSysPath(output_package).c_str());
        zipClose(zf, nullptr);
        return false;
      }
    }
  }

  zipClose(zf, nullptr);
  return true;
}

int main(int argc, char** argv) {
  if (argc == 3 || argc == 4) {
    std::string contents = ReadFile(argv[1]);
    if (contents.empty())
      return 0;

    kiwi::base::FilePath f = FromSysPath(argv[1]);
    // Generate normal resource
    kiwi::base::FilePath module_name = f.BaseName().RemoveExtension();

    kiwi::base::FilePath dir_name = FromSysPath(argv[2]);
    kiwi::base::FilePath out_cxx =
        dir_name.Append(module_name.value() + FILE_PATH_LITERAL(".h"));
    kiwi::base::FilePath out_lua =
        dir_name.Append(module_name.value() + FILE_PATH_LITERAL(".lua"));

    try {
      auto items = LoadResourceFromJSON(contents);
      std::string cxx = GenerateCxx(items, module_name.AsUTF8Unsafe());
      std::string lua = GenerateLua(items, module_name.AsUTF8Unsafe());

      if (!WriteFile(cxx, ToSysPath(out_cxx))) {
        printf("Error while writing file to %s\n", ToSysPath(out_cxx).c_str());
        return 1;
      }

      if (!WriteFile(lua, ToSysPath(out_lua))) {
        printf("Error while writing file to %s\n", ToSysPath(out_lua).c_str());
        return 1;
      }

      if (argc == 4 && argv[3] == std::string_view("--pack")) {
        kiwi::base::FilePath out_pak =
            dir_name.Append(module_name.value() + OUTPUT_SUFFIX);
        printf("Packing resources to %s\n", ToSysPath(out_pak).c_str());
        if (!PackAllFileInResource(f.DirName(), items, contents, out_pak))
          return 1;
      }

    } catch (std::exception e) {
      printf("%s\n", e.what());
      return 1;
    }

  } else {
    printf(
        "Vita resource compiler\n"
        "vrc [path-to-json-file] [output-dir] (--pack)"
        "vrc [path-of-key-pem] [output-file]");
    return 1;
  }

  return 0;
}
